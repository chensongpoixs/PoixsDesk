/***********************************************************************************************
created: 		2022-01-19

author:			chensong

purpose:		input_device
输赢不重要，答案对你们有什么意义才重要。

光阴者，百代之过客也，唯有奋力奔跑，方能生风起时，是时代造英雄，英雄存在于时代。或许世人道你轻狂，可你本就年少啊。 看护好，自己的理想和激情。


我可能会遇到很多的人，听他们讲好2多的故事，我来写成故事或编成歌，用我学来的各种乐器演奏它。
然后还可能在一个国家遇到一个心仪我的姑娘，她可能会被我帅气的外表捕获，又会被我深邃的内涵吸引，在某个下雨的夜晚，她会全身淋透然后要在我狭小的住处换身上的湿衣服。
3小时候后她告诉我她其实是这个国家的公主，她愿意向父皇求婚。我不得已告诉她我是穿越而来的男主角，我始终要回到自己的世界。
然后我的身影慢慢消失，我看到她眼里的泪水，心里却没有任何痛苦，我才知道，原来我的心被丢掉了，我游历全世界的原因，就是要找回自己的本心。
于是我开始有意寻找各种各样失去心的人，我变成一块砖头，一颗树，一滴水，一朵白云，去听大家为什么会失去自己的本心。
我发现，刚出生的宝宝，本心还在，慢慢的，他们的本心就会消失，收到了各种黑暗之光的侵蚀。
从一次争论，到嫉妒和悲愤，还有委屈和痛苦，我看到一只只无形的手，把他们的本心扯碎，蒙蔽，偷走，再也回不到主人都身边。
我叫他本心猎手。他可能是和宇宙同在的级别 但是我并不害怕，我仔细回忆自己平淡的一生 寻找本心猎手的痕迹。
沿着自己的回忆，一个个的场景忽闪而过，最后发现，我的本心，在我写代码的时候，会回来。
安静，淡然，代码就是我的一切，写代码就是我本心回归的最好方式，我还没找到本心猎手，但我相信，顺着这个线索，我一定能顺藤摸瓜，把他揪出来。
************************************************************************************************/

#ifndef _C_INPUT_DEVICE_H_
#define _C_INPUT_DEVICE_H_
//#include <winnt.h>
#include "cnet_types.h"
#include "api/data_channel_interface.h"
#include <map>
#include "cprotocol.h"
#include "cint_point.h"
#include "csingleton.h"
#include <set>
#include "json.hpp"
#include <unordered_map>
#include <list>
#include <mutex>
namespace chen {
	/**
	*  @author chensong
	*  @date 2022-01-19
	*  @brief 鼠标信息结构体（Mouse Information Structure）
	*  
	*  cmouse_info结构体用于存储鼠标按键信息。用于跟踪每个消费者的鼠标状态，
	*  支持多消费者同时控制的情况。
	*  
	*  鼠标信息数据结构（Mouse Information Data Structure）：
	*  
	*    0                   1                   2                   3
	*    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
	*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	*   |  m_mouse_key                                                  |
	*   |  (32 bits: 鼠标按键代码)                                       |
	*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	*   |  m_key                                                        |
	*   |  (1 bit: 按键是否按下)                                         |
	*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	*  
	*  鼠标按键代码说明（Mouse Key Code Description）：
	*  - 0x0001: 左键 (MK_LBUTTON)
	*  - 0x0002: 右键 (MK_RBUTTON)
	*  - 0x0010: 中键 (MK_MBUTTON)
	*  - 0x0020: X键1 (MK_XBUTTON1)
	*  - 0x0040: X键2 (MK_XBUTTON2)
	*  
	*  @note 用于跟踪每个消费者的鼠标按键状态
	*  @note 支持多消费者同时控制的场景
	*/
	struct cmouse_info 
	{
		/**
		*  @author chensong
		*  @date 2022-01-19
		*  @brief 鼠标按键代码（Mouse Key Code）
		*  
		*  该成员变量用于存储鼠标按键代码。表示当前按下的鼠标按键。
		*  
		*  按键代码格式（Key Code Format）：
		*  
		*    0                   1                   2                   3
		*    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  Bit 0: MK_LBUTTON (左键)                                     |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  Bit 1: MK_RBUTTON (右键)                                     |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  Bit 4: MK_MBUTTON (中键)                                     |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  Bit 5: MK_XBUTTON1                                           |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  Bit 6: MK_XBUTTON2                                           |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*  
		*  @note 初始化为0，表示没有按键按下
		*  @note 可以同时按下多个按键（位标志）
		*/
		uint32  m_mouse_key;
		
		/**
		*  @author chensong
		*  @date 2022-01-19
		*  @brief 按键状态标志（Key State Flag）
		*  
		*  该成员变量用于指示按键是否处于按下状态。
		*  
		*  @note 初始化为false，表示按键未按下
		*  @note true表示按键处于按下状态
		*/
		bool	m_key;
		
		/**
		*  @author chensong
		*  @date 2022-01-19
		*  @brief 构造函数（Constructor）
		*  
		*  该构造函数用于初始化鼠标信息结构体，将所有成员变量设置为默认值。
		*  
		*  @note m_mouse_key初始化为0
		*  @note m_key初始化为false
		*/
		cmouse_info()
			: m_mouse_key(0)
			, m_key(false) {}
	};

	/**
	*  @author chensong
	*  @date 2022-01-19
	*  @brief 输入设备管理类（Input Device Manager Class）
	*  
	*  cinput_device类用于管理远程输入设备事件。它接收来自数据通道的输入事件
	*  （键盘、鼠标），并将这些事件转换为本地输入操作。
	*  
	*  输入设备管理架构（Input Device Management Architecture）：
	*  
	*    0                   1                   2                   3
	*    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
	*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	*   |                      cinput_device                             |
	*   |  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |
	*   |  | 消息接收层:                                                  | |
	*   |  |   - OnMessage(DataBuffer): 接收二进制消息                    | |
	*   |  |   - OnMessage(json): 接收JSON消息                           | |
	*   |  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |
	*   |  | 消息处理层:                                                  | |
	*   |  |   - insert_message(): 插入消息到队列                        | |
	*   |  |   - _work_pthread(): 工作线程处理消息                       | |
	*   |  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |
	*   |  | 输入事件处理器:                                              | |
	*   |  |   - 键盘事件: OnKeyDown/OnKeyUp/OnKeyPress/OnKeyChar       | |
	*   |  |   - 鼠标事件: OnMouseDown/OnMouseUp/OnMouseMove等          | |
	*   |  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |
	*   |  | 坐标转换:                                                    | |
	*   |  |   - _UnquantizeAndDenormalize(): 反量化坐标                 | |
	*   |  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |
	*   |  | 多消费者管理:                                                | |
	*   |  |   - m_all_consumer: 每个消费者的鼠标状态                    | |
	*   |  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |
	*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	*  
	*  输入事件处理流程（Input Event Processing Flow）：
	*  
	*    0                   1                   2                   3
	*    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
	*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	*   |  1. 接收数据通道消息（DataBuffer或JSON）                       |
	*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	*   |  2. 解析消息类型（EToStreamMsg枚举）                            |
	*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	*   |  3. 根据消息类型查找对应的处理器函数                            |
	*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	*   |  4. 调用处理器函数处理输入事件                                  |
	*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	*   |  5. 转换为本地输入操作（SendInput/PostMessage）                |
	*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	*  
	*  输入事件消息格式（Input Event Message Format）：
	*  
	*    0                   1                   2                   3
	*    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
	*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	*   |  二进制消息格式:                                                |
	*   |  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |
	*   |  | message_type (EToStreamMsg枚举，8位)                         | |
	*   |  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |
	*   |  | payload_data (可变长度)                                      | |
	*   |  |   - 键盘事件: key_code, modifiers                            | |
	*   |  |   - 鼠标事件: x, y, buttons, delta                          | |
	*   |  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |
	*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	*   |  JSON消息格式:                                                  |
	*   |  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |
	*   |  | {                                                           | |
	*   |  |   "type": "keydown" | "mouseMove" | ...                    | |
	*   |  |   "key": "A", "x": 100, "y": 200, ...                      | |
	*   |  | }                                                           | |
	*   |  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |
	*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	*  
	*  @note 支持二进制和JSON两种消息格式
	*  @note 使用单例模式访问：s_input_device
	*  @note 支持多消费者同时控制
	*  @note 使用工作线程异步处理消息，避免阻塞
	*  
	*  使用示例：
	*  @code
	*  s_input_device.init();
	*  s_input_device.startup();
	*  s_input_device.OnMessage(consumer_id, data_buffer);
	*  @endcode
	*/
	class cinput_device
	{
	private:
		typedef bool(cinput_device::*input_device_handler_type)(const uint8*& Data, uint32 size);
		typedef bool(cinput_device::*rtc_input_device_handler_type)(const nlohmann::json & data);
		typedef std::unordered_map<EToStreamMsg, input_device_handler_type>			M_INPUT_DEVICE_MAP;
		typedef std::unordered_map<EToStreamMsg, rtc_input_device_handler_type>			M_RTC_INPUT_DEVICE_MAP;
	public:
		/**
		*  @author chensong
		*  @date 2022-01-19
		*  @brief 构造函数（Constructor）
		*  
		*  该构造函数用于创建输入设备管理器实例。初始化所有成员变量为默认值。
		*  
		*  初始化说明：
		*  - m_stoped: 初始化为false，表示未停止
		*  - m_input_device: 初始化输入设备处理器映射表
		*  - m_rtc_input_device: 初始化RTC输入设备处理器映射表
		*  - m_int_point: 初始化坐标点
		*  - m_input_list: 初始化消息队列
		*  - m_init: 初始化为false，表示未初始化
		*  
		*  @note 构造函数初始化映射表，注册所有输入事件处理器
		*/
		cinput_device();
		
		/**
		*  @author chensong
		*  @date 2022-01-19
		*  @brief 析构函数（Destructor）
		*  
		*  该析构函数用于清理输入设备管理器实例。停止工作线程并清理所有资源。
		*  
		*  清理流程：
		*  1. 停止工作线程
		*  2. 清理消息队列
		*  3. 清理所有成员变量
		*  
		*  @note 析构函数会自动调用Destroy()方法清理资源
		*/
		~cinput_device();

	public:
		/**
		*  @author chensong
		*  @date 2022-01-19
		*  @brief 初始化输入设备管理器（Initialize Input Device Manager）
		*  
		*  该方法用于初始化输入设备管理器。注册所有输入事件处理器，准备接收
		*  和处理输入事件。
		*  
		*  初始化流程（Initialization Flow）：
		*  
		*    0                   1                   2                   3
		*    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  1. 注册二进制消息处理器到m_input_device映射表                 |
		*   |     - OnKeyDown, OnKeyUp, OnKeyPress, OnKeyChar               |
		*   |     - OnMouseDown, OnMouseUp, OnMouseMove等                    |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  2. 注册JSON消息处理器到m_rtc_input_device映射表               |
		*   |     - OnRtcKeyDown, OnRtcKeyUp, OnRtcKeyPress等               |
		*   |     - OnRtcMouseDown, OnRtcMouseUp, OnRtcMouseMove等          |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  3. 初始化坐标点m_int_point                                   |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  4. 设置m_init标志为true                                      |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*  
		*  @return 返回true表示初始化成功，false表示初始化失败
		*  @note 需要在startup()之前调用
		*  @note 注册所有消息处理器后，可以开始处理输入事件
		*  
		*  使用示例：
		*  @code
		*  if (s_input_device.init()) {
		*      s_input_device.startup();
		*  }
		*  @endcode
		*/
		bool init();

		/**
		*  @author chensong
		*  @date 2022-01-19
		*  @brief 设置鼠标坐标点（Set Mouse Point）
		*  
		*  该方法用于设置鼠标的初始坐标点。坐标点用于坐标转换和反量化。
		*  
		*  坐标点格式（Point Format）：
		*  
		*    0                   1                   2                   3
		*    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  x: 水平坐标 (32位，像素单位)                                 |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  y: 垂直坐标 (32位，像素单位)                                 |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*  
		*  @param x 水平坐标，单位为像素
		*  @param y 垂直坐标，单位为像素
		*  @return 返回true表示设置成功，false表示设置失败
		*  @note 坐标点用于坐标转换和反量化操作
		*  
		*  使用示例：
		*  @code
		*  s_input_device.set_point(0, 0);  // 设置初始坐标点
		*  @endcode
		*/
		bool set_point(uint32 x, uint32 y);
		
		/**
		*  @author chensong
		*  @date 2022-01-19
		*  @brief 销毁输入设备管理器（Destroy Input Device Manager）
		*  
		*  该方法用于销毁输入设备管理器。停止工作线程并清理所有资源。
		*  
		*  销毁流程：
		*  1. 设置m_stoped标志为true
		*  2. 等待工作线程退出
		*  3. 清理消息队列
		*  4. 清理所有成员变量
		*  
		*  @note 销毁后对象不能再使用
		*/
		void Destroy();
		
		/**
		*  @author chensong
		*  @date 2022-01-19
		*  @brief 启动输入设备管理器（Startup Input Device Manager）
		*  
		*  该方法用于启动输入设备管理器。创建工作线程开始处理输入事件。
		*  
		*  启动流程（Startup Flow）：
		*  
		*    0                   1                   2                   3
		*    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  1. 检查是否已初始化（m_init标志）                             |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  2. 创建工作线程m_thread                                      |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  3. 工作线程执行_work_pthread()方法                            |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  4. 工作线程开始处理消息队列中的消息                           |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*  
		*  @note 需要在init()之后调用
		*  @note 启动后会创建工作线程处理输入事件
		*  
		*  使用示例：
		*  @code
		*  s_input_device.init();
		*  s_input_device.startup();
		*  @endcode
		*/
		void startup();
		
	public:
		/**
		*  @author chensong
		*  @date 2022-01-19
		*  @brief 处理数据通道消息 - DataBuffer版本（Handle Data Channel Message - DataBuffer Version）
		*  
		*  该方法用于处理来自数据通道的二进制消息。解析消息类型并调用对应的处理器。
		*  
		*  消息处理流程（Message Processing Flow）：
		*  
		*    0                   1                   2                   3
		*    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  1. 解析消息类型（第一个字节，EToStreamMsg枚举）                |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  2. 在m_input_device映射表中查找对应的处理器函数               |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  3. 调用处理器函数处理消息                                    |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  4. 处理器函数解析消息数据并执行输入操作                      |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*  
		*  二进制消息格式（Binary Message Format）：
		*  
		*    0                   1                   2                   3
		*    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  message_type (8 bits: EToStreamMsg枚举)                      |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  payload_data (可变长度，根据消息类型不同)                     |
		*   |  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |
		*   |  | 键盘消息: key_code (8 bits), modifiers (8 bits)            | |
		*   |  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |
		*   |  | 鼠标消息: x (16 bits), y (16 bits), buttons (8 bits)       | |
		*   |  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |
		*   |  | 滚轮消息: delta (16 bits)                                  | |
		*   |  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*  
		*  @param consumer_id 消费者ID，标识消息来源的消费者
		*  @param Buffer 数据缓冲区，包含二进制消息数据
		*  @return 返回true表示处理成功，false表示处理失败
		*  @note 该方法会立即处理消息，不放入队列
		*  @note 用于处理二进制格式的输入事件消息
		*  
		*  使用示例：
		*  @code
		*  webrtc::DataBuffer buffer = ...;
		*  s_input_device.OnMessage("consumer_1", buffer);
		*  @endcode
		*/
		bool OnMessage(const std::string & consumer_id, const webrtc::DataBuffer& Buffer);
		
		/**
		*  @author chensong
		*  @date 2022-01-19
		*  @brief 处理数据通道消息 - JSON版本（Handle Data Channel Message - JSON Version）
		*  
		*  该方法用于处理来自数据通道的JSON消息。解析JSON格式并调用对应的处理器。
		*  
		*  JSON消息格式（JSON Message Format）：
		*  
		*    0                   1                   2                   3
		*    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  {                                                             |
		*   |    "type": "keydown" | "mouseMove" | "mouseWheel" | ...       |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |    "key": "A" | "Enter" | ... (键盘事件)                      |
		*   |    "code": "KeyA" (键盘代码)                                   |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |    "x": 100, "y": 200 (鼠标事件)                              |
		*   |    "buttons": 1 (鼠标按键)                                     |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |    "delta": 120 (滚轮事件)                                    |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  }                                                             |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*  
		*  消息处理流程（Message Processing Flow）：
		*  
		*    0                   1                   2                   3
		*    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  1. 解析JSON消息，提取"type"字段                               |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  2. 根据type值查找EToStreamMsg枚举值                           |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  3. 在m_rtc_input_device映射表中查找对应的处理器函数          |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  4. 调用处理器函数处理JSON消息                                |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  5. 处理器函数解析JSON数据并执行输入操作                      |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*  
		*  @param datachannel JSON对象，包含输入事件数据
		*  @return 返回true表示处理成功，false表示处理失败
		*  @note 该方法会立即处理消息，不放入队列
		*  @note 用于处理JSON格式的输入事件消息
		*  
		*  使用示例：
		*  @code
		*  nlohmann::json msg = {{"type", "keydown"}, {"key", "A"}};
		*  s_input_device.OnMessage(msg);
		*  @endcode
		*/
		bool OnMessage(const nlohmann::json & datachannel);
		
		/**
		*  @author chensong
		*  @date 2022-01-19
		*  @brief 插入消息到队列（Insert Message to Queue）
		*  
		*  该方法用于将消息插入到处理队列。工作线程会从队列中取出消息并处理。
		*  
		*  消息队列管理（Message Queue Management）：
		*  
		*    0                   1                   2                   3
		*    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  m_input_list (消息队列)                                       |
		*   |  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |
		*   |  | Buffer 1: 第一个消息                                       | |
		*   |  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |
		*   |  | Buffer 2: 第二个消息                                       | |
		*   |  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |
		*   :  ...                                                           :
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  m_input_mutex: 保护队列的互斥锁                              |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*  
		*  消息插入流程（Message Insertion Flow）：
		*  
		*    0                   1                   2                   3
		*    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  1. 获取m_input_mutex互斥锁                                    |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  2. 将Buffer添加到m_input_list队列末尾                         |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  3. 释放互斥锁                                                |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  4. 工作线程从队列中取出消息并处理                            |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*  
		*  @param Buffer 数据缓冲区，包含要处理的消息数据
		*  @note 该方法使用互斥锁保护队列，线程安全
		*  @note 消息会在工作线程中异步处理
		*  
		*  使用示例：
		*  @code
		*  webrtc::DataBuffer buffer = ...;
		*  s_input_device.insert_message(buffer);
		*  @endcode
		*/
		void insert_message(const webrtc::DataBuffer& Buffer);
	public:
		/**
		*  @author chensong
		*  @date 2022-01-19
		*  @brief 请求质量控制（Request Quality Control）
		*  
		*  该方法用于处理质量控制请求消息。用于控制视频质量参数。
		*  
		*  质量控制消息格式（Quality Control Message Format）：
		*  
		*    0                   1                   2                   3
		*    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  message_type: EToStreamMsg::RequestQualityControl             |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  quality_level (8 bits: 质量级别)                              |
		*   |  - 0: 低质量                                                   |
		*   |  - 1: 中等质量                                                 |
		*   |  - 2: 高质量                                                   |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*  
		*  @param Data 指向消息数据的指针，会被推进到消息结束位置
		*  @param size 消息数据的总大小，单位为字节
		*  @return 返回true表示处理成功，false表示处理失败
		*  @note 用于远程控制视频质量
		*/
		bool OnRequestQualityControl(const uint8*& Data,   uint32 size);
		
		/**
		*  @author chensong
		*  @date 2022-01-19
		*  @brief 处理字符输入事件 - 二进制版本（Handle Key Character Event - Binary Version）
		*  
		*  该方法用于处理字符输入事件。当用户输入字符时，会将字符转换为本地输入操作。
		*  
		*  字符输入消息格式（Key Character Message Format）：
		*  
		*    0                   1                   2                   3
		*    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  message_type: EToStreamMsg::KeyChar                           |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  char_code (16 bits: 字符Unicode编码)                          |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  modifiers (8 bits: 修饰键标志)                                |
		*   |  - Bit 0: Ctrl                                                  |
		*   |  - Bit 1: Shift                                                 |
		*   |  - Bit 2: Alt                                                   |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*  
		*  @param Data 指向消息数据的指针，会被推进到消息结束位置
		*  @param size 消息数据的总大小，单位为字节
		*  @return 返回true表示处理成功，false表示处理失败
		*  @note 字符输入会触发本地字符输入事件
		*  @note 用于文本输入场景
		*/
		bool OnKeyChar( const uint8*& Data,   uint32 size);
		
		/**
		*  @author chensong
		*  @date 2022-01-19
		*  @brief 处理字符输入事件 - JSON版本（Handle Key Character Event - JSON Version）
		*  
		*  该方法用于处理JSON格式的字符输入事件。
		*  
		*  JSON消息格式：
		*  {
		*    "type": "keyChar",
		*    "char": "A",
		*    "code": 65,
		*    "modifiers": {"ctrl": false, "shift": true, "alt": false}
		*  }
		*  
		*  @param data JSON对象，包含字符输入数据
		*  @return 返回true表示处理成功，false表示处理失败
		*  @note 用于处理JSON格式的字符输入事件
		*/
		bool OnRtcKeyChar(const nlohmann::json & data );

		/**
		*  @author chensong
		*  @date 2022-01-19
		*  @brief 处理按键按下事件 - 二进制版本（Handle Key Down Event - Binary Version）
		*  
		*  该方法用于处理按键按下事件。将远程按键按下操作转换为本地按键事件。
		*  
		*  按键按下消息格式（Key Down Message Format）：
		*  
		*    0                   1                   2                   3
		*    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  message_type: EToStreamMsg::KeyDown                           |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  key_code (16 bits: 虚拟键码)                                  |
		*   |  - 0x41: 'A'键                                                 |
		*   |  - 0x0D: Enter键                                               |
		*   |  - 0x1B: Escape键                                              |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  modifiers (8 bits: 修饰键标志)                                |
		*   |  - Bit 0: Ctrl键按下                                           |
		*   |  - Bit 1: Shift键按下                                          |
		*   |  - Bit 2: Alt键按下                                            |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*  
		*  按键事件序列（Key Event Sequence）：
		*  
		*    0                   1                   2                   3
		*    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  1. OnKeyDown(): 按键按下事件                                  |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  2. OnKeyPress(): 字符键按下事件（如果按下字符键）             |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  3. OnKeyChar(): 字符输入事件（如果按下字符键）                |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  4. OnKeyUp(): 按键释放事件                                    |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*  
		*  @param Data 指向消息数据的指针，会被推进到消息结束位置
		*  @param size 消息数据的总大小，单位为字节
		*  @return 返回true表示处理成功，false表示处理失败
		*  @note 按键按下会触发本地按键按下事件
		*  @note keydown事件在所有键按下时都会触发
		*/
		bool OnKeyDown(const uint8*& Data,   uint32 size);
		
		/**
		*  @author chensong
		*  @date 2022-01-19
		*  @brief 处理按键按下事件 - JSON版本（Handle Key Down Event - JSON Version）
		*  
		*  该方法用于处理JSON格式的按键按下事件。
		*  
		*  JSON消息格式：
		*  {
		*    "type": "keydown",
		*    "key": "A",
		*    "code": "KeyA",
		*    "keyCode": 65,
		*    "modifiers": {"ctrl": false, "shift": true, "alt": false}
		*  }
		*  
		*  @param data JSON对象，包含按键按下数据
		*  @return 返回true表示处理成功，false表示处理失败
		*  @note 用于处理JSON格式的按键按下事件
		*/
		bool OnRtcKeyDown(const nlohmann::json & data);
		
		/**
		*  @author chensong
		*  @date 2022-01-19
		*  @brief 处理按键释放事件 - 二进制版本（Handle Key Up Event - Binary Version）
		*  
		*  该方法用于处理按键释放事件。将远程按键释放操作转换为本地按键事件。
		*  
		*  按键释放消息格式（Key Up Message Format）：
		*  
		*    0                   1                   2                   3
		*    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  message_type: EToStreamMsg::KeyUp                             |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  key_code (16 bits: 虚拟键码)                                  |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  modifiers (8 bits: 修饰键标志)                                |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*  
		*  @param Data 指向消息数据的指针，会被推进到消息结束位置
		*  @param size 消息数据的总大小，单位为字节
		*  @return 返回true表示处理成功，false表示处理失败
		*  @note 按键释放会触发本地按键释放事件
		*  @note keyup事件在键释放时触发
		*/
		bool OnKeyUp(const uint8* &Data,   uint32 size);
		
		/**
		*  @author chensong
		*  @date 2022-01-19
		*  @brief 处理按键释放事件 - JSON版本（Handle Key Up Event - JSON Version）
		*  
		*  该方法用于处理JSON格式的按键释放事件。
		*  
		*  JSON消息格式：
		*  {
		*    "type": "keyup",
		*    "key": "A",
		*    "code": "KeyA",
		*    "keyCode": 65
		*  }
		*  
		*  @param data JSON对象，包含按键释放数据
		*  @return 返回true表示处理成功，false表示处理失败
		*  @note 用于处理JSON格式的按键释放事件
		*/
		bool OnRtcKeyUp(const nlohmann::json & data);

		/**
		*  @author chensong
		*  @date 2022-01-19
		*  @brief 处理按键按下事件（字符键）- 二进制版本（Handle Key Press Event - Binary Version）
		*  
		*  该方法用于处理按键按下事件。keypress事件只在按下字符键时触发，
		*  与keydown不同，keydown在所有键按下时都会触发。
		*  
		*  事件触发顺序（Event Trigger Sequence）：
		*  - keydown: 按下键盘键时立即触发（所有键）
		*  - keypress: 紧接着keydown触发（仅字符键，如'A', '1'等）
		*  - keyup: 释放键盘键时触发（所有键）
		*  
		*  按键按下消息格式（Key Press Message Format）：
		*  
		*    0                   1                   2                   3
		*    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  message_type: EToStreamMsg::KeyPress                          |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  key_code (16 bits: 虚拟键码)                                  |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  char_code (16 bits: 字符Unicode编码)                          |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  modifiers (8 bits: 修饰键标志)                                |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*  
		*  @param Data 指向消息数据的指针，会被推进到消息结束位置
		*  @param size 消息数据的总大小，单位为字节
		*  @return 返回true表示处理成功，false表示处理失败
		*  @note keypress只在字符键按下时触发
		*  @note 功能键（如F1-F12）不会触发keypress事件
		*/
		bool OnKeyPress(const uint8*& Data,   uint32 size);
		
		/**
		*  @author chensong
		*  @date 2022-01-19
		*  @brief 处理按键按下事件（字符键）- JSON版本（Handle Key Press Event - JSON Version）
		*  
		*  该方法用于处理JSON格式的按键按下事件。
		*  
		*  JSON消息格式：
		*  {
		*    "type": "keypress",
		*    "key": "A",
		*    "code": "KeyA",
		*    "charCode": 65
		*  }
		*  
		*  @param data JSON对象，包含按键按下数据
		*  @return 返回true表示处理成功，false表示处理失败
		*  @note 用于处理JSON格式的按键按下事件
		*/
		bool OnRtcKeyPress(const nlohmann::json & data);

		/**
		*  @author chensong
		*  @date 2022-01-19
		*  @brief 处理鼠标进入控制范围事件 - 二进制版本（Handle Mouse Enter Event - Binary Version）
		*  
		*  该方法用于处理鼠标进入控制范围事件。当鼠标进入可控制区域时触发。
		*  
		*  鼠标进入消息格式（Mouse Enter Message Format）：
		*  
		*    0                   1                   2                   3
		*    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  message_type: EToStreamMsg::MouseEnter                        |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  x (16 bits: 水平坐标，归一化或量化值)                         |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  y (16 bits: 垂直坐标，归一化或量化值)                         |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*  
		*  @param Data 指向消息数据的指针，会被推进到消息结束位置
		*  @param size 消息数据的总大小，单位为字节
		*  @return 返回true表示处理成功，false表示处理失败
		*  @note 鼠标进入控制范围时会触发此事件
		*  @note 用于通知鼠标已进入可控制区域
		*/
		bool OnMouseEnter(const uint8*& Data,   uint32 size);
		
		/**
		*  @author chensong
		*  @date 2022-01-19
		*  @brief 处理鼠标进入控制范围事件 - JSON版本（Handle Mouse Enter Event - JSON Version）
		*  
		*  该方法用于处理JSON格式的鼠标进入事件。
		*  
		*  JSON消息格式：
		*  {
		*    "type": "mouseEnter",
		*    "x": 100,
		*    "y": 200
		*  }
		*  
		*  @param data JSON对象，包含鼠标进入数据
		*  @return 返回true表示处理成功，false表示处理失败
		*  @note 用于处理JSON格式的鼠标进入事件
		*/
		bool OnRtcMouseEnter(const nlohmann::json & data);

		/**
		*  @author chensong
		*  @date 2022-01-19
		*  @brief 处理鼠标离开控制范围事件 - 二进制版本（Handle Mouse Leave Event - Binary Version）
		*  
		*  该方法用于处理鼠标离开控制范围事件。当鼠标离开可控制区域时触发。
		*  
		*  鼠标离开消息格式（Mouse Leave Message Format）：
		*  
		*    0                   1                   2                   3
		*    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  message_type: EToStreamMsg::MouseLeave                        |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  x (16 bits: 水平坐标)                                         |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  y (16 bits: 垂直坐标)                                         |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*  
		*  @param Data 指向消息数据的指针，会被推进到消息结束位置
		*  @param size 消息数据的总大小，单位为字节
		*  @return 返回true表示处理成功，false表示处理失败
		*  @note 鼠标离开控制范围时会触发此事件
		*  @note 用于通知鼠标已离开可控制区域
		*/
		bool OnMouseLeave(const uint8*& Data,   uint32 size);
		
		/**
		*  @author chensong
		*  @date 2022-01-19
		*  @brief 处理鼠标离开控制范围事件 - JSON版本（Handle Mouse Leave Event - JSON Version）
		*  
		*  该方法用于处理JSON格式的鼠标离开事件。
		*  
		*  JSON消息格式：
		*  {
		*    "type": "mouseLeave",
		*    "x": 100,
		*    "y": 200
		*  }
		*  
		*  @param data JSON对象，包含鼠标离开数据
		*  @return 返回true表示处理成功，false表示处理失败
		*  @note 用于处理JSON格式的鼠标离开事件
		*/
		bool OnRtcMouseLeave(const nlohmann::json & data);
		
		/**
		*  @author chensong
		*  @date 2022-01-19
		*  @brief 处理鼠标按下事件 - 二进制版本（Handle Mouse Down Event - Binary Version）
		*  
		*  该方法用于处理鼠标按下事件。当用户按下鼠标按键时，会将远程鼠标
		*  按下操作转换为本地鼠标事件。注意：在Web环境中，左右键可能互换。
		*  
		*  鼠标按下消息格式（Mouse Down Message Format）：
		*  
		*    0                   1                   2                   3
		*    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  message_type: EToStreamMsg::MouseDown                         |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  x (16 bits: 水平坐标，归一化或量化值)                         |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  y (16 bits: 垂直坐标，归一化或量化值)                         |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  buttons (8 bits: 鼠标按键标志)                                |
		*   |  - Bit 0: 左键按下                                             |
		*   |  - Bit 1: 右键按下                                             |
		*   |  - Bit 2: 中键按下                                             |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*  
		*  鼠标按键映射（Mouse Button Mapping）：
		*  - Web环境可能左右键互换：remote_left -> local_right
		*  - 需要根据平台和配置进行映射
		*  
		*  @param Data 指向消息数据的指针，会被推进到消息结束位置
		*  @param size 消息数据的总大小，单位为字节
		*  @return 返回true表示处理成功，false表示处理失败
		*  @note 鼠标按下会触发本地鼠标按下事件（onclick事件）
		*  @note 在Web环境中，左右键可能互换（right <-> left）
		*/
		bool OnMouseDown(const uint8*& Data,   uint32 size);
		
		/**
		*  @author chensong
		*  @date 2022-01-19
		*  @brief 处理鼠标按下事件 - JSON版本（Handle Mouse Down Event - JSON Version）
		*  
		*  该方法用于处理JSON格式的鼠标按下事件。
		*  
		*  JSON消息格式：
		*  {
		*    "type": "mouseDown",
		*    "x": 100,
		*    "y": 200,
		*    "buttons": 1,
		*    "button": 0
		*  }
		*  
		*  @param data JSON对象，包含鼠标按下数据
		*  @return 返回true表示处理成功，false表示处理失败
		*  @note 用于处理JSON格式的鼠标按下事件
		*/
		bool OnRtcMouseDown(const nlohmann::json & data);
		
		/**
		*  @author chensong
		*  @date 2022-01-19
		*  @brief 处理鼠标移动事件 - 二进制版本（Handle Mouse Move Event - Binary Version）
		*  
		*  该方法用于处理鼠标移动事件。当鼠标移动时，会将远程鼠标移动操作
		*  转换为本地鼠标移动事件。
		*  
		*  鼠标移动消息格式（Mouse Move Message Format）：
		*  
		*    0                   1                   2                   3
		*    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  message_type: EToStreamMsg::MouseMove                         |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  x (16 bits: 水平坐标，归一化或量化值)                         |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  y (16 bits: 垂直坐标，归一化或量化值)                         |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  buttons (8 bits: 鼠标按键状态，移动时是否按下按键)            |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*  
		*  坐标处理流程（Coordinate Processing Flow）：
		*  
		*    0                   1                   2                   3
		*    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  1. 接收归一化或量化的坐标值 (x, y)                            |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  2. _UnquantizeAndDenormalize() 反量化和反归一化               |
		*   |     - 将归一化坐标转换为像素坐标                               |
		*   |     - 将量化坐标转换为实际坐标                                 |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  3. 转换为本地屏幕坐标                                         |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  4. 移动鼠标到新坐标位置                                       |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*  
		*  @param Data 指向消息数据的指针，会被推进到消息结束位置
		*  @param size 消息数据的总大小，单位为字节
		*  @return 返回true表示处理成功，false表示处理失败
		*  @note 鼠标移动会触发本地鼠标移动事件
		*  @note 坐标需要反量化和反归一化处理
		*  @note 支持移动时按下按键的情况（拖拽操作）
		*/
		bool OnMouseMove(const uint8* &Data,   uint32 size);
		
		/**
		*  @author chensong
		*  @date 2022-01-19
		*  @brief 处理鼠标移动事件 - JSON版本（Handle Mouse Move Event - JSON Version）
		*  
		*  该方法用于处理JSON格式的鼠标移动事件。
		*  
		*  JSON消息格式：
		*  {
		*    "type": "mouseMove",
		*    "x": 100,
		*    "y": 200,
		*    "buttons": 0
		*  }
		*  
		*  @param data JSON对象，包含鼠标移动数据
		*  @return 返回true表示处理成功，false表示处理失败
		*  @note 用于处理JSON格式的鼠标移动事件
		*/
		bool OnRtcMouseMove(const nlohmann::json & data);
		
		/**
		*  @author chensong
		*  @date 2022-01-19
		*  @brief 处理鼠标释放事件 - 二进制版本（Handle Mouse Up Event - Binary Version）
		*  
		*  该方法用于处理鼠标释放事件。当用户释放鼠标按键时，会将远程鼠标
		*  释放操作转换为本地鼠标事件。
		*  
		*  鼠标释放消息格式（Mouse Up Message Format）：
		*  
		*    0                   1                   2                   3
		*    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  message_type: EToStreamMsg::MouseUp                           |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  x (16 bits: 水平坐标)                                         |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  y (16 bits: 垂直坐标)                                         |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  buttons (8 bits: 释放的鼠标按键标志)                          |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*  
		*  @param Data 指向消息数据的指针，会被推进到消息结束位置
		*  @param size 消息数据的总大小，单位为字节
		*  @return 返回true表示处理成功，false表示处理失败
		*  @note 鼠标释放会触发本地鼠标释放事件
		*  @note 需要与MouseDown配对使用
		*/
		bool OnMouseUp(const uint8*& Data,   uint32 size);
		
		/**
		*  @author chensong
		*  @date 2022-01-19
		*  @brief 处理鼠标释放事件 - JSON版本（Handle Mouse Up Event - JSON Version）
		*  
		*  该方法用于处理JSON格式的鼠标释放事件。
		*  
		*  JSON消息格式：
		*  {
		*    "type": "mouseUp",
		*    "x": 100,
		*    "y": 200,
		*    "button": 0
		*  }
		*  
		*  @param data JSON对象，包含鼠标释放数据
		*  @return 返回true表示处理成功，false表示处理失败
		*  @note 用于处理JSON格式的鼠标释放事件
		*/
		bool OnRtcMouseUp(const nlohmann::json & data);
		
		/**
		*  @author chensong
		*  @date 2022-01-19
		*  @brief 处理鼠标双击事件 - 二进制版本（Handle Mouse Double Click Event - Binary Version）
		*  
		*  该方法用于处理鼠标双击事件。当用户双击鼠标按键时，会将远程鼠标
		*  双击操作转换为本地鼠标双击事件。
		*  
		*  鼠标双击消息格式（Mouse Double Click Message Format）：
		*  
		*    0                   1                   2                   3
		*    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  message_type: EToStreamMsg::MouseDoubleClick                  |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  x (16 bits: 水平坐标)                                         |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  y (16 bits: 垂直坐标)                                         |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  buttons (8 bits: 双击的鼠标按键标志)                          |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*  
		*  @param Data 指向消息数据的指针，会被推进到消息结束位置
		*  @param size 消息数据的总大小，单位为字节
		*  @return 返回true表示处理成功，false表示处理失败
		*  @note 鼠标双击会触发本地鼠标双击事件
		*  @note 双击通常由两个连续的单击事件组成
		*/
		bool OnMouseDoubleClick(const uint8*& Data,   uint32 size);
		
		/**
		*  @author chensong
		*  @date 2022-01-19
		*  @brief 处理鼠标双击事件 - JSON版本（Handle Mouse Double Click Event - JSON Version）
		*  
		*  该方法用于处理JSON格式的鼠标双击事件。
		*  
		*  JSON消息格式：
		*  {
		*    "type": "mouseDoubleClick",
		*    "x": 100,
		*    "y": 200,
		*    "button": 0
		*  }
		*  
		*  @param data JSON对象，包含鼠标双击数据
		*  @return 返回true表示处理成功，false表示处理失败
		*  @note 用于处理JSON格式的鼠标双击事件
		*/
		bool OnRtcMouseDoubleClick(const nlohmann::json & data);
		
		/**
		*  @author chensong
		*  @date 2022-01-19
		*  @brief 处理鼠标滚轮滚动事件 - 二进制版本（Handle Mouse Wheel Event - Binary Version）
		*  
		*  该方法用于处理鼠标滚轮滚动事件。当用户滚动鼠标滚轮时，会将远程滚轮
		*  滚动操作转换为本地滚轮事件。
		*  
		*  鼠标滚轮消息格式（Mouse Wheel Message Format）：
		*  
		*    0                   1                   2                   3
		*    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  message_type: EToStreamMsg::MouseWheel                        |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  x (16 bits: 水平坐标)                                         |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  y (16 bits: 垂直坐标)                                         |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  delta (16 bits: 滚轮滚动增量，有符号数)                      |
		*   |  - 正值: 向上滚动                                              |
		*   |  - 负值: 向下滚动                                              |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  modifiers (8 bits: 修饰键标志，如Ctrl+滚轮缩放)              |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*  
		*  滚轮事件说明（Wheel Event Description）：
		*  - delta > 0: 向上滚动（远离用户）
		*  - delta < 0: 向下滚动（靠近用户）
		*  - delta = 120: 标准滚动单位（Windows）
		*  - Ctrl+滚轮: 通常用于缩放操作
		*  
		*  @param Data 指向消息数据的指针，会被推进到消息结束位置
		*  @param size 消息数据的总大小，单位为字节
		*  @return 返回true表示处理成功，false表示处理失败
		*  @note 滚轮滚动会触发本地滚轮事件
		*  @note delta值表示滚动方向和距离
		*/
		bool OnMouseWheel(const uint8*& Data,   uint32 size);
		
		/**
		*  @author chensong
		*  @date 2022-01-19
		*  @brief 处理鼠标滚轮滚动事件 - JSON版本（Handle Mouse Wheel Event - JSON Version）
		*  
		*  该方法用于处理JSON格式的鼠标滚轮滚动事件。
		*  
		*  JSON消息格式：
		*  {
		*    "type": "mouseWheel",
		*    "x": 100,
		*    "y": 200,
		*    "deltaX": 0,
		*    "deltaY": 120,
		*    "deltaMode": 0
		*  }
		*  
		*  @param data JSON对象，包含鼠标滚轮数据
		*  @return 返回true表示处理成功，false表示处理失败
		*  @note 用于处理JSON格式的鼠标滚轮滚动事件
		*  @note deltaY > 0表示向上滚动，deltaY < 0表示向下滚动
		*/
		bool OnRtcMouseWheel(const nlohmann::json & data);
	private:
		/**
		*  @author chensong
		*  @date 2022-01-19
		*  @brief 反量化和反归一化坐标 - uint16版本（Unquantize and Denormalize Coordinates - uint16 Version）
		*  
		*  该方法用于将量化并归一化的坐标值（uint16）转换为实际的像素坐标。
		*  坐标在传输过程中可能被量化和归一化以节省带宽。
		*  
		*  坐标转换流程（Coordinate Conversion Flow）：
		*  
		*    0                   1                   2                   3
		*    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  1. 接收归一化的坐标值 (0.0 - 1.0)                              |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  2. 反归一化: 乘以屏幕宽度/高度                                  |
		*   |     - x = normalized_x * screen_width                          |
		*   |     - y = normalized_y * screen_height                         |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  3. 反量化: 将量化值转换为实际值                                |
		*   |     - 根据量化级别调整坐标值                                    |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  4. 转换为实际像素坐标                                          |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*  
		*  坐标转换格式（Coordinate Conversion Format）：
		*  
		*    0                   1                   2                   3
		*    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  输入: 归一化坐标 (0.0 - 1.0)                                   |
		*   |  normalized_x (16 bits: 0x0000 - 0xFFFF)                       |
		*   |  normalized_y (16 bits: 0x0000 - 0xFFFF)                       |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  处理: 反归一化和反量化                                         |
		*   |  x = denormalize(normalized_x) * screen_width                  |
		*   |  y = denormalize(normalized_y) * screen_height                 |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  输出: 实际像素坐标                                             |
		*   |  InOutX (32 bits: 0 - screen_width)                            |
		*   |  InOutY (32 bits: 0 - screen_height)                           |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*  
		*  @param InOutX 输入输出参数，输入归一化坐标，输出实际像素坐标
		*  @param InOutY 输入输出参数，输入归一化坐标，输出实际像素坐标
		*  @note 坐标转换用于将远程坐标映射到本地屏幕坐标
		*  @note 需要知道本地屏幕分辨率才能正确转换
		*/
		void _UnquantizeAndDenormalize(uint16& InOutX, uint16& InOutY);

		/**
		*  @author chensong
		*  @date 2022-01-19
		*  @brief 反量化和反归一化坐标 - int16版本（Unquantize and Denormalize Coordinates - int16 Version）
		*  
		*  该方法用于将量化并归一化的坐标偏移值（int16）转换为实际的像素偏移。
		*  用于处理鼠标移动的相对坐标。
		*  
		*  坐标偏移转换流程（Coordinate Delta Conversion Flow）：
		*  
		*    0                   1                   2                   3
		*    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  1. 接收归一化的坐标偏移值 (-1.0 - 1.0)                         |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  2. 反归一化: 乘以屏幕宽度/高度                                  |
		*   |     - delta_x = normalized_delta_x * screen_width              |
		*   |     - delta_y = normalized_delta_y * screen_height             |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  3. 反量化: 将量化值转换为实际偏移值                            |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  4. 转换为实际像素偏移                                          |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*  
		*  坐标偏移格式（Coordinate Delta Format）：
		*  
		*    0                   1                   2                   3
		*    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  输入: 归一化偏移 (-1.0 - 1.0)                                  |
		*   |  normalized_delta_x (16 bits: -0x8000 - 0x7FFF)                |
		*   |  normalized_delta_y (16 bits: -0x8000 - 0x7FFF)                |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  输出: 实际像素偏移                                             |
		*   |  InOutX (32 bits: -screen_width - screen_width)                |
		*   |  InOutY (32 bits: -screen_height - screen_height)              |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*  
		*  @param InOutX 输入输出参数，输入归一化偏移，输出实际像素偏移（有符号）
		*  @param InOutY 输入输出参数，输入归一化偏移，输出实际像素偏移（有符号）
		*  @note 用于处理相对坐标移动（如拖拽操作）
		*  @note 负值表示向左/上移动，正值表示向右/下移动
		*/
		void _UnquantizeAndDenormalize(int16& InOutX, int16& InOutY);
		
	private:
		/**
		*  @author chensong
		*  @date 2022-01-19
		*  @brief 工作线程函数（Worker Thread Function）
		*  
		*  该方法在工作线程中运行，持续从消息队列中取出消息并处理。
		*  使用异步处理避免阻塞主线程。
		*  
		*  工作线程处理流程（Worker Thread Processing Flow）：
		*  
		*    0                   1                   2                   3
		*    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  1. 循环直到m_stoped为true                                      |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  2. 获取m_input_mutex互斥锁                                    |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  3. 检查m_input_list队列是否为空                                |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  4. 如果队列不为空，取出第一个消息                              |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  5. 释放互斥锁                                                |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  6. 处理消息（解析类型并调用对应处理器）                        |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  7. 返回步骤2继续处理                                          |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*  
		*  消息队列处理（Message Queue Processing）：
		*  
		*    0                   1                   2                   3
		*    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  m_input_list (FIFO队列)                                       |
		*   |  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |
		*   |  | [消息1] -> [消息2] -> [消息3] -> ...                      | |
		*   |  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |
		*   |  工作线程按顺序处理队列中的消息                                 |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*  
		*  @note 该方法在独立线程中运行，避免阻塞主线程
		*  @note 使用互斥锁保护消息队列，确保线程安全
		*  @note 消息按FIFO顺序处理
		*  
		*  使用示例：
		*  @code
		*  // 由startup()方法创建工作线程并调用此方法
		*  // 无需手动调用
		*  @endcode
		*/
		void _work_pthread();
		
	private:
		/**
		*  @author chensong
		*  @date 2022-01-19
		*  @brief 禁用拷贝构造函数（Disable Copy Constructor）
		*  
		*  该拷贝构造函数被声明为私有，禁止复制输入设备管理器实例。
		*  输入设备管理器使用单例模式，不应该被复制。
		*  
		*  @note 单例模式不允许复制
		*/
		cinput_device(const cinput_device&);
		
		/**
		*  @author chensong
		*  @date 2022-01-19
		*  @brief 禁用赋值操作符（Disable Assignment Operator）
		*  
		*  该赋值操作符被声明为私有，禁止赋值输入设备管理器实例。
		*  输入设备管理器使用单例模式，不应该被赋值。
		*  
		*  @note 单例模式不允许赋值
		*/
		cinput_device& operator =(const cinput_device&);
		
	private:
		/**
		*  @author chensong
		*  @date 2022-01-19
		*  @brief 停止标志（Stop Flag）
		*  
		*  该成员变量用于指示输入设备管理器是否已停止。当设置为true时，
		*  工作线程会退出循环并停止处理消息。
		*  
		*  @note 初始化为false，表示未停止
		*  @note 通过Destroy()方法设置为true
		*  @note 工作线程检查此标志决定是否退出
		*/
		bool								m_stoped;
		
		/**
		*  @author chensong
		*  @date 2022-01-19
		*  @brief 输入设备处理器映射表（Input Device Handler Map）
		*  
		*  该成员变量用于存储二进制消息类型到处理函数的映射。
		*  键为EToStreamMsg枚举值，值为对应的处理器函数指针。
		*  
		*  映射表结构（Map Structure）：
		*  
		*    0                   1                   2                   3
		*    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  EToStreamMsg::KeyDown -> OnKeyDown()                          |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  EToStreamMsg::KeyUp -> OnKeyUp()                              |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  EToStreamMsg::MouseDown -> OnMouseDown()                      |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  EToStreamMsg::MouseMove -> OnMouseMove()                      |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   :  ...                                                            :
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*  
		*  @note 在init()方法中注册所有处理器
		*  @note 用于快速查找并调用对应的处理器函数
		*  @note 使用unordered_map实现O(1)查找
		*/
		M_INPUT_DEVICE_MAP					m_input_device;
		
		/**
		*  @author chensong
		*  @date 2022-01-19
		*  @brief RTC输入设备处理器映射表（RTC Input Device Handler Map）
		*  
		*  该成员变量用于存储JSON消息类型到处理函数的映射。
		*  键为EToStreamMsg枚举值，值为对应的JSON处理器函数指针。
		*  
		*  映射表结构（Map Structure）：
		*  
		*    0                   1                   2                   3
		*    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  EToStreamMsg::KeyDown -> OnRtcKeyDown()                       |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  EToStreamMsg::KeyUp -> OnRtcKeyUp()                           |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  EToStreamMsg::MouseDown -> OnRtcMouseDown()                   |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  EToStreamMsg::MouseMove -> OnRtcMouseMove()                   |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   :  ...                                                            :
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*  
		*  @note 在init()方法中注册所有JSON处理器
		*  @note 用于处理JSON格式的输入事件消息
		*  @note 使用unordered_map实现O(1)查找
		*/
		M_RTC_INPUT_DEVICE_MAP				m_rtc_input_device;
		
		/**
		*  @author chensong
		*  @date 2022-01-19
		*  @brief 整数坐标点（Integer Point）
		*  
		*  该成员变量用于存储当前鼠标的坐标点。坐标点用于坐标转换和跟踪。
		*  
		*  坐标点结构（Point Structure）：
		*  
		*    0                   1                   2                   3
		*    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  X: 水平坐标 (32 bits: 像素单位)                                |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  Y: 垂直坐标 (32 bits: 像素单位)                                |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*  
		*  @note 通过set_point()方法设置
		*  @note 用于坐标转换和相对移动计算
		*/
		FIntPoint							m_int_point;
		
		/**
		*  @author chensong
		*  @date 2022-01-19
		*  @brief 所有消费者的鼠标信息（All Consumers Mouse Information）
		*  
		*  该成员变量用于存储每个消费者的鼠标按键状态。支持多消费者同时控制
		*  的场景，每个消费者有独立的鼠标状态跟踪。
		*  
		*  消费者鼠标状态结构（Consumer Mouse State Structure）：
		*  
		*    0                   1                   2                   3
		*    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  consumer_id (string)                                          |
		*   |  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |
		*   |  | button_id (uint32) -> cmouse_info                           | |
		*   |  |   0: 左键状态 (m_mouse_key, m_key)                          | |
		*   |  |   1: 右键状态 (m_mouse_key, m_key)                          | |
		*   |  |   2: 中键状态 (m_mouse_key, m_key)                          | |
		*   |  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |
		*   :  ... (其他消费者)                                              :
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*  
		*  @note 支持多消费者同时控制
		*  @note 每个消费者可以独立跟踪鼠标按键状态
		*  @note 键为消费者ID，值为按键ID到鼠标信息的映射
		*/
		std::map<std::string, std::map<uint32, cmouse_info>>	m_all_consumer;
		
		/**
		*  @author chensong
		*  @date 2022-01-19
		*  @brief 当前操作的鼠标ID（Current Operating Mouse ID）
		*  
		*  该成员变量用于存储当前正在操作的鼠标ID。用于标识当前活跃的消费者。
		*  
		*  @note 初始化为空字符串
		*  @note 用于跟踪当前活跃的鼠标控制会话
		*/
		std::string							m_mouse_id; //当前操作的id
		
		/**
		*  @author chensong
		*  @date 2022-01-19
		*  @brief 输入消息队列（Input Message Queue）
		*  
		*  该成员变量用于存储待处理的输入消息队列。消息按FIFO顺序处理。
		*  
		*  消息队列结构（Message Queue Structure）：
		*  
		*    0                   1                   2                   3
		*    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  m_input_list (FIFO队列)                                       |
		*   |  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |
		*   |  | [DataBuffer 1] -> [DataBuffer 2] -> [DataBuffer 3] -> ... | |
		*   |  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |
		*   |  队列头部                                                      |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  工作线程从队列头部取出消息并处理                               |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*  
		*  @note 使用std::list实现FIFO队列
		*  @note 使用m_input_mutex互斥锁保护，线程安全
		*  @note 消息通过insert_message()添加到队列
		*  @note 工作线程从队列中取出消息并处理
		*/
		std::list< webrtc::DataBuffer>		m_input_list;
		
		/**
		*  @author chensong
		*  @date 2022-01-19
		*  @brief 输入消息队列互斥锁（Input Message Queue Mutex）
		*  
		*  该成员变量用于保护输入消息队列的线程安全访问。
		*  多个线程可能同时访问消息队列，需要使用互斥锁保护。
		*  
		*  互斥锁使用场景（Mutex Usage Scenarios）：
		*  - insert_message(): 添加消息到队列时加锁
		*  - _work_pthread(): 从队列取出消息时加锁
		*  
		*  @note 使用std::mutex实现互斥锁
		*  @note 保护m_input_list队列的线程安全访问
		*  @note 避免竞态条件和数据竞争
		*/
		std::mutex							m_input_mutex;

		/**
		*  @author chensong
		*  @date 2022-01-19
		*  @brief 工作线程（Worker Thread）
		*  
		*  该成员变量用于存储工作线程句柄。工作线程负责异步处理输入消息队列。
		*  
		*  工作线程生命周期（Worker Thread Lifecycle）：
		*  
		*    0                   1                   2                   3
		*    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  1. startup()创建线程                                           |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  2. 线程执行_work_pthread()方法                                 |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  3. 线程持续处理消息队列中的消息                                 |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  4. Destroy()设置m_stoped=true，线程退出                        |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  5. 等待线程结束并清理                                          |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*  
		*  @note 在startup()方法中创建
		*  @note 在Destroy()方法中等待线程结束
		*  @note 使用std::thread管理线程生命周期
		*  @note 工作线程避免阻塞主线程
		*/
		std::thread							m_thread;
		
		/**
		*  @author chensong
		*  @date 2022-01-19
		*  @brief 初始化标志（Initialization Flag）
		*  
		*  该成员变量用于指示输入设备管理器是否已初始化。原子布尔类型，
		*  可以在多线程环境下安全访问。
		*  
		*  @note 初始化为false，表示未初始化
		*  @note 通过init()方法设置为true
		*  @note 使用std::atomic_bool实现线程安全的布尔标志
		*/
		std::atomic_bool					m_init;
		
#if defined(_MSC_VER)
		/**
		*  @author chensong
		*  @date 2022-01-19
		*  @brief 主窗口句柄（Main Window Handle）- Windows平台
		*  
		*  该成员变量用于存储主窗口句柄（仅Windows平台）。窗口句柄用于
		*  Windows API调用，如发送输入消息等。
		*  
		*  窗口句柄格式（Window Handle Format）：
		*  
		*    0                   1                   2                   3
		*    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  HWND: 窗口句柄 (指针大小: 32位或64位)                          |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*   |  NULL: 无效句柄                                                |
		*   |  非NULL: 有效窗口句柄                                           |
		*   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		*  
		*  @note 仅在Windows平台（_MSC_VER）下使用
		*  @note 用于Windows API调用（如PostMessage、SendInput等）
		*  @note 窗口句柄用于标识目标窗口
		*/
		HWND								m_main_win;
#endif // #if defined(_MSC_VER)


		
	};
	//extern cinput_device   g_input_device_mgr;
	#define 	s_input_device chen::csingleton<chen::cinput_device>::get_instance()
}

#endif // _C_INPUT_DEVICE_H_